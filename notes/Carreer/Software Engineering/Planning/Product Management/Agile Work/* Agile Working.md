[[Agile Modeling Strategies]]


----


## Agile Software Development: A gentle introduction


The most important thing to know about Agile methods or processes is that there is no such thing. 

There are only Agile teams.

The processes we describe as Agile are environments for a team to learn how to be Agile.

The most brilliant programmers alive working competitively in an ego-rich environment can’t get as much done as ordinary programmers working cooperatively as a self disciplined and self-organizing team. 

You need a process where team empowerment and collaboration thrive to reach your full potential.

The second change is making the customer the one who funds the software development, a valuable and essential team member.

When the dead line gets close a traditional approach to reducing scope is to let the developers decide what will work properly and what won't. Instead let the customer make scope decisions a little at a time throughout the project.  

When your customer, or domain expert works directly with the development team everyone learns something new about the problem. 

True domain expertise and experience is essential to finding a simple, elegant, correct solution. A document can have plenty of information, but real knowledge is hard to put on paper. 

Left alone programmers must assume they know everything they need. When asking questions is difficult or slow the knowledge gap grows.

The system will get built, but it won't solve the problem like one guided by an expert on a daily basis.

Perhaps the biggest problem with software development is changing requirements. 

Agile processes accept the reality of change versus the hunt for complete, rigid specifications. 

There are domains where requirements can't change, but most projects have changing requirements.

For most projects readily accepting changes can actually cost less than ensuring requirements will never change.  

We can produce working software starting with the first week of development so why not show it to the customer?

We can learn so much more about the project requirements in the context of a working system.

The changes we get this way are usually the most important to implement.

Agile also means a fundamental change in how we manage our projects. 

If working software is what you will deliver then measure your progress by how much you have right now.

We will change our management style to be based on getting working software done a little at a time.

The documents we used to create as project milestones may still be useful, just not as a measure of progress.

Instead of managing our activities and waiting till the project ends for software, we will manage our requirements and demonstrate each new version to the customer. 

It is a hard change to make but it opens up new ways to develop software.

## Manage Your Goals Instead of Activities
Now we can flip the axis of the previous chart. 

We visualize the activities, our process itself as the constant. 

Our process is applied to our user stories in sequence. The activities are on going and the user stories get what ever they need.  


# Don't panic.

With professional software engineers on our project we can relax knowing that the team will do what is needed to get the job done. 

Any activity needed with any combination of people will just get done without any further scheduling or ceremony. This is the spirit and benefit of a self organizing team.

So now when we create our schedule we pencil in the features in order of importance. 

This offers us a different kind of efficiency; 

we can change our minds about what we want without huge cost over runs. 

We can also stop at any time and have the most important features done.  

An Agile process takes the traditional process and turns it 90 degrees on its side.

This allows managers to get an estimated cost per feature instead of per activity.

Customers can make the difficult decisions about what can be left undone in an intelligent way.

If you find yourself running short on money you will not have wasted your money on analysis and design for features that will never be coded and tested.

Costs make more sense this way since customers can't pick and choose which activities should be done. 

This gives us a "shopping list" style of requirements and planning.

---
# Agile workshop

---

### Design  
> Who ever finds a problem knows enough to design a solution.  
> Flexibility isn't building for every imaginable possibility; it's having as little to change as possible.
> A good design can be explained to someone else using four blank cards.  
> A design which doesn't meet business needs is bad, no matter how pretty.  UML was designed to document complexity, not expose it.


### Develop
> 
### Test
> 
### Deploy
> 
### Review
> 

---



## Agile Process Proverbs

  

Here are some things to think about. I have summarized them into pithy sentences, added bullet points and called them proverbs to make them sound important. Don't be fooled. These are ideas, not rules. Ideas to help you think about making your current process, what ever it is, a more Agile process.

  

## Iterative Planning

  

The best way to meet customer objectives is to explicitly schedule their completion.

Trying to catch up is the fastest way to get further behind.

The changes you get late in a project are very valuable because you paid the most to get them.

One third of your requirements will represent two thirds of the project's value.

Showing someone something they can change is helpful, showing something they can't change is spiteful.

Iterative development gives you a few "oh drat"s during development instead of one big "AW SHIT" at the end.

  

## Honest Plans

An estimate not based on a measurement is a guess; an estimate based on a measurement is a prediction.

He who does the work sets the estimate.

If software is what you want to deliver then measure progress by how much you have working right now.

  

## Team Empowerment

The most important thing on a project is good leadership; the least important thing is who leads.

If you can see a need for leadership you know enough to lead.

When you only have responsibility you will know worry, but when you also have authority you will know opportunity.

The organization of your team will be reflected in the code. (Conway's Law)

Calm and relaxed plus confident yields decisive.

Count how many people are on the project, now communicate like a group that size.

Hermits don’t share, communities are based on sharing.

## Documentation/Models

Agile models are paintings, not photographs.

The creation of a document is an implicit agreement to keep it up to date or destroy it.

Without the use they are just cases.

Ideas move faster than documents.

  

## Customers/Product Owners

There is more to owning software than just paying for it.

Negotiating is basic to being human, don't give it up that right before the project even begins.

  

## Managers/Scrum Masters

Challenge your team intellectually or they will challenge themselves in ways you wouldn't have chosen.

Demanding estimates change seems like taking control, but you lose control by not making a decision.

People don't scale, teams do.

The only way to guarantee bad decisions is to make all of them yourself.

## Developers/Team Members

Big changes cause big problems.

Egoless programming doesn't work; expand your ego to include everyone's code.

Don't guess, measure it.

Don't theorize, try it.

Everything you did today can be done over tomorrow in half an hour and be better.

Measure twice cut once saves wood, but software isn't made of wood.

The best way to get help is to offer help.

  
  

---

  

## Agile

Process Proverbs

  

Here are some things to think about. I have summarized them into pithy sentences, added bullet points and called them proverbs to make them sound important. Don't be fooled. These are ideas, not rules. Ideas to help you think about making your current process, what ever it is, a more Agile process.

  
  

---

  

## Iterative

Planning

  

The best way to meet customer objectives is to explicitly schedule their completion.

Trying to catch up is the fastest way to get further behind.

The changes you get late in a project are very valuable because you paid the most to get them.

One third of your requirements will represent two thirds of the project's value.

Showing someone something they can change is helpful, showing something they can't change is spiteful.

Iterative development gives you a few "oh drat"s during development instead of one big "AW SHIT" at the end.

  
  

---

  

## Honest

Plans

An estimate not based on a measurement is a guess; an estimate based on a measurement is a prediction.

He who does the work sets the estimate.

If software is what you want to deliver then measure progress by how much you have working right now.

  
  

---

  

## Team

Empowerment

The most important thing on a project is good leadership; the least important thing is who leads.

If you can see a need for leadership you know enough to lead.

When you only have responsibility you will know worry, but when you also have authority you will know opportunity.

The organization of your team will be reflected in the code. (Conway's Law)

Calm and relaxed plus confident yields decisive.

Count how many people are on the project, now communicate like a group that size.

Hermits don’t share, communities are based on sharing.

  

---

  

## Documentation

/Models

Agile models are paintings, not photographs.

The creation of a document is an implicit agreement to keep it up to date or destroy it.

Without the use they are just cases.

Ideas move faster than documents.

  
  

---

  

## Customers

/Product Owners

There is more to owning software than just paying for it.

Negotiating is basic to being human, don't give it up that right before the project even begins.

  
  

---

  

## Managers

/Scrum Masters

Challenge your team intellectually or they will challenge themselves in ways you wouldn't have chosen.

Demanding estimates change seems like taking control, but you lose control by not making a decision.

People don't scale, teams do.

The only way to guarantee bad decisions is to make all of them yourself.

  
  

---

  

## Developers

/Team Members

Big changes cause big problems.

Egoless programming doesn't work; expand your ego to include everyone's code.

Don't guess, measure it.

Don't theorize, try it.

Everything you did today can be done over tomorrow in half an hour and be better.

Measure twice cut once saves wood, but software isn't made of wood.

The best way to get help is to offer help.

  
  

---

  

## Testing

  

The first test is the hardest.

Your test suite is more valuable than your code.

The harder the test is to create the greater your savings.

Where there is a will there is a way to test.

If you want a good suite of tests next year you must start collecting them today.

  

---

  

## Process

  

If you don't use your process it can't help you; if your process doesn't help, you won't use it.

The one essential ingredient that turns repetitive development into iterative development is feedback.

If less doesn't work try more, if more doesn't work try less, if neither works stop doing it.

If 10 people slow the project down by just 10% each it will take twice as long.

If it isn't fun you're doing something wrong.

A hammer without a good process is a sore thumb waiting to happen.

Process is something you do, not something you do to someone.

The person least likely to save time is the person in the biggest hurry.

The least disciplined team member has the greatest control over your process.

  
  

---

  

## Simplicity

  

Simple is subjective so judge it subjectively as testable, browsable, understandable, and explainable.

The best way to guarantee it costs too much is to add something you don't need.

If it takes you too long to refactor than you are not refactoring enough.

A simple solution always takes less time than a complex one.

If you always try the simplest thing next you will always work as simply as you can.

  
  

---

  

## Design
Who ever finds a problem knows enough to design a solution.

Flexibility isn't building for every imaginable possibility; it's having as little to change as possible.

A good design can be explained to someone else using four blank cards.

A design which doesn't meet business needs is bad, no matter how pretty.

UML was designed to document complexity, not expose it.

 ---
 
 